# Глава 4. Быстрая сортировка

## Разделяй и властвуй

Рекурсивная стратегия решения задач, которая заключается в приведении задачи (упрощении, делении, уменьшении) к простейшему базовому случаю.

1. Сначала нужно найти этот базовый случай
2. Затем найти способ упростить исходную задачу до него

### Алгоритм Евклида

Примером применения стратегии "Разделяй и властвуй" является нахождение наибольшего общего делителя двух чисел с помощью [алгоритма Евклида](./euclidean-algorithm).

При этом числа постенно уменьшаются, пока не достигнут собственно значения наибольшего общего делителя.

**Пример**

У фермера есть большой прямоугольный участок земли. Он хочет разделить его на *равные* *квадратные* участки максимального размера.

По сути эта задача сводится к нахождению НОД для длины и ширины исходного участка.

### Работа с массивами

При использовании "Разделяй и властвуй" в работе с массивами базовый случай - это пустой массив или массив, состоящий из одного элемента. С ними очень просто работать.

**Пример**

Рекурсивно посчитать сумму всех элементов массива.

Сумма всех элементов равна сумме первого элемента и сумме всех оставшихся элементов. Таким образом, мы по одному изымаем элементы из массива, упрощая его до базового случая - пустого массива, сумма элементов которого равно 0.

```
sum([1, 2, 3, 4]); // 10
sum([]); // 0
```

[Код sum](./utils/recursive-sum.js)

**Проверка**

```
npm run recursive-sum
```

**Пример**

Найдите наибольшее число в списке.

```
max([1,2,100,4]); // 100
max([-1, -4, -10]); // -1
```

[Код max](./utils/recursive-max.js)

**Проверка**

```
npm run recursive-max
```

**Пример**

Бинарный поиск также применяет стратегию "Разделяй и властвуй".

Базовый случай: верхняя и нижняя границы фрагмента массива в котором происходит поиск равны (массив из одного элемента).

Рекурсивная реализация.

```
const sortedList = [1, 3, 5, 7, 9];

binarySearch(sortedList, 1); // 0
binarySearch(sortedList, 7); // 3
binarySearch(sortedList, -1); // undefined
```

[Код binarySearch](./utils/binary-search.js)

**Проверка**

```
npm run recursive-binary-search
```

## Быстрая сортировка

Алгоритм сортировки, основанный на принципе "Разделяй и властвуй".

Базовый случай - это массив с одним элементом, который сам по себе уже является отсортированным. Базовым случаем также является пустой массив.

В исходном массиве выбирается `опорный` элемент. Затем массив делится на три части:

- элементы, которые *меньше* опорного
- опорный элемент
- элементы, которые *больше* опорного

Теперь задача сводится к двум меньшим задачам: отсортировать два подмассива.

Рекурсивное разделение происходит до тех пор, пока не будет достигнут базовый случай.

### Пример

```
quickSort([10, 5, 2, 3]); // [2, 3, 5, 10]
```

[Код quickSort](./utils/quick-sort.js)

**Проверка**

```
npm run quick-sort
```

### Эффективность алгоритма

Эффективность алгоритма во многом зависит от выбора `опорного` элемента.

**В худшем случае**: O(n<sup>2</sup>)

Массив уже отсортирован, в качестве опорного берется первый элемент.

**В среднем случае**: O(n * log n)

Массив уже отсортирован, в качестве опорного берется средний элемент.

На каждом витке алгоритм обращается ко всем элементам массива, независимо от того, как они отсортированы. Поэтому эффективность зависит от высоты стека. В худшем случае высота стека будет равна `n`. В лучшем случае высота стека `log n`, так как каждый раз массив делится на две равные части.

Сортировка слиянием (еще один алгоритм сортировки) имеет эффективность O(n * log n) в худшем случае. Можно было бы предположить, что выгоднее всегда использовать сортировку слиянием, а не быструю сортировку.

Однако при одинаковом времени O-большое эти алгоритмы имеют разное реальное время выполнения. В O-большом игнорируется константа (время выполнения одной операции), но у быстрой сортировки она меньше, чем у сортировки слиянием.